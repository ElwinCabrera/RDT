####################################################
0. Academic Integrity

1. Implementation
  1.1 Alternating-Bit
  1.2 Go back-N protocol
  1.3 Selective repeat
  
   
2. Experiments
  2.1 Experiment 1
    <description of this experiment>
    2.1.1 alternating bit
    2.1.2 Go-Back-N
    2.1.3 selective repeat
    <observations>
    
  2.2 Experiment 2
    <description of this experiment>
    2.2.1 alternating bit
    2.2.2 Go-Back-N
    2.2.3 selective repeat
    <observations>
    
  2.3 Experiment 3
    <description of this experiment>
    2.3.1 alternating bit
    2.3.2 Go-Back-N
    2.3.3 selective repeat
    <observations>
    
  2.4 Experiment 4
    <description of this experiment>
    2.4.1 alternating bit
    2.4.2 Go-Back-N
    2.4.3 selective repeat
    <observations>
    
    
3. Conclusions



####################################################


1.1 Alternating-Bit

1.1.1 A_Output


The first thing that this function does is wait on some data from layer 5 to be sent to B. The program then encapsulates
this data into a packet that we can send to layer 3 later. Once the data is in a packet its then put into a queue and if no packets are currently in the link or if the program is not trying to resolve a corrupt packet then we pop that packet from the queue, set our current packet to the packet we just popped, and send it down to layer 3 and start a timer. However, if a packet is currently using the link or if the program is trying to resolve a corrupt packet (can occur under high corruption thus will take long for B to receive a valid packet ) then we just keep that packet in the queue for later transmission.  

1.1.2 A_Input

A only gets acknowledgment packets from B so that is the only type of packets that A_Input handles. When A_Input gets a packet it first checks if that packet is valid and not corrupt. After the validation, it then checks if the acknowledgment number corresponds to the latest packet that A sent. If the acknowledgment number is equal to the last packet A sent, then A will stop the timer and check if the queue has any more packets to transmit if yes then it will pop from the queue, start a timer,  and then send next packet to layer 3.  

1.1.3 A_Interrupt 

The interrupt mechanism used for this protocol is simple. Every time that A sends a new packet it starts a timer. The only time that the timer is stopped is when A receives an acknowledgment for the current packet and when the A_Interrupt function is called. When A_Interrupt is called it simply retransmits the current packet that is saved as a variable as ``struct pkt current_pkt''.

1.1.4 B_Input

When B first gets a packet it checks if the packet is valid and not corrupt and then checks if the packet is a duplicate. If the packet is a duplicate it simply sends an acknowledgment corresponding to that duplicate packet. If the packet if not valid then B will just return. However, if the packet is valid and if it's not a duplicate packet then it sends the data to the application and then sends an acknowledgment packet corresponding the packet B just received. 



1.2 Go-Back-N

1.2.1 A_Output

This function is similar to the alternating bit's version of A_Output in 1.1.1, with only two modifications. The first modification is the introduction of a window of packets which is just an array of packets of size N where N is the window size which is specified by the user running the program. The second modification is that instead of having only one packet in the link we can send as many packets to layer 3 as long as the window is not full, if the window is full then we just push that packet in a queue. 

1.2.2 A_Input

This function does something similar to the alternating bit version of A_Input in 1.1.2 with only one change. Since we introduced the window we have to check the acknowledgment against the first packet in our window, this is because our window can't move unless the first packet in the window is acknowledged. When the first packet in our window is acknowledged then we shift our window right up until the next unacknowledged packet and then we push more packets into the window if our queue of buffered packets is not empty. An interesting thing
that this function does is that if the acknowledgment does not correspond to the first packet in the window then it does nothing this is explained in 1.2.3. 

1.2.3 A_Interrupt 

The interrupt mechanism is simple. Whenever a new packet is the first packet in the window then a timer is started. When that timer runs out, which means that the first packet in the window was not acknowledged in time, then A sends all packets that are currently in that window to layer 3. This means that whenever A gets an acknowledgment packet it doesn't care if the acknowledgment packet is not the expected acknowledgment in which case A will just wait for the timer to run out to retransmit the window. This can be problematic under high loss or high corruption rate as the program will keep sending the entire window often causing long execution time. 


1.2.4 B_Input

Here it just checks if the packet is valid, if not then it just finishes and does not send an acknowledgment. Then it checks if the packet just received is a duplicate if it's not then it sends the data to the application. Finally regardless if the packet is a duplicate or not it sends an acknowledgment corresponding to the packet just received.








1.3 Selective Repeat

1.3.1 A_Output

The implementation for this function is nearly identical to Go-Back-N's version of A_Output  see section 1.2.1. The only difference is that a packet is encapsulated in a different structure and that is what gets pushed to the queue, the struct used is shown below.

After we put a packet in this structure we set a timeout for that packet by adding the current time and the time interval we want that packet to timeout in the future.


1.3.2 A_Input

This function behaves in the same way that Go-Back-N's A_Input does in section 1.2.2

1.3.3 A_Interrupt 

The interrupt implementation for this protocol is the most interesting out of all three protocols this is because each packet needs to have its own timer but we only have available one timer interrupt. To achieve this we need a way to implement multiple logical timers from one given timer. What I decided to do was to start the timer once in the beginning and have it interrupt very often endlessly. I decided to have the timer interrupt once every 1-time unit (I could have gone lower if I wanted to be more accurate). Since the timer is interrupting very often all I have to do is have an int or float variable that corresponds to each packet and every time an interrupt 
happens I check all packets and their timeouts to see if the time at this moment is equal to the packets timeout, if yes then I send that one packet to layer 3. This is why a packet is encapsulated in a different struct because we need to hold extra information about the packet.    


1.3.4 B_Input

In the previous protocols, B didn't change much. With selective repeat B now also has a window and its implemented in the same way that A's window is implemented. Another difference from the previous protocols is that whenever B gets a packet that is out of order then it buffers that packet by putting it in a queue so when its time for that packet to be sent to the application B already has it and can deliver it in order right away. 
 
  

















 
